CREATE SEQUENCE bertopic_run_id_seq INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 8 NO CYCLE;;
CREATE SEQUENCE chunk_id_seq INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 9073830 NO CYCLE;;
CREATE TYPE artist_type AS ENUM ( 'PERSON', 'GROUP', 'ORCHESTRA', 'CHOIR', 'CHARACTER', 'OTHER' );;;
CREATE TYPE rel_Artist_Member_Of_Artist AS ENUM ( 'HAS_MEMBER' );;;
CREATE TYPE rel_Artist_Originates_From_Location AS ENUM ( 'ORIGINATES_FROM_LOCATION' );;;
CREATE TYPE rel_Artist_Performed_At_Event AS ENUM ( 'PERFORMED_AT' );;;
CREATE TYPE rel_Artist_Performed_Song AS ENUM ( 'PERFORMED_SONG' );;;
CREATE TYPE rel_Artist_Person_Role_Played_Role AS ENUM ( 'PLAYED_ROLE' );;;
CREATE TYPE rel_Artist_Plays_Instrument AS ENUM ( 'PLAYS_INSTRUMENT' );;;
CREATE TYPE rel_Entity_Has_URL AS ENUM ( 'HAS_URL' );;;
CREATE TYPE rel_Has_Genre AS ENUM ( 'HAS_GENRE' );;;
CREATE TYPE rel_Release_By_Label AS ENUM ( 'RELEASED_BY_LABEL' );;;
CREATE TYPE rel_Song_Appears_On_Release AS ENUM ( 'APPEARS_ON' );;;
CREATE TYPE rel_Song_Based_On_Work AS ENUM ( 'BASED_ON_WORK' );;;
CREATE TYPE rel_Song_Featured_Artist AS ENUM ( 'FEATURED_ARTIST' );;;
CREATE TABLE bertopic_hierarchy(run_id INTEGER NOT NULL, parent_id INTEGER, parent_name VARCHAR, child_left_id INTEGER, child_left_name VARCHAR, child_right_id INTEGER, child_right_name VARCHAR, distance DOUBLE);;
CREATE TABLE bertopic_runs(run_id INTEGER DEFAULT(nextval('bertopic_run_id_seq')) PRIMARY KEY, model_run_name VARCHAR NOT NULL UNIQUE, ingested_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE bertopic_topics(run_id INTEGER, topic_id INTEGER, "name" VARCHAR, count INTEGER, representation_main VARCHAR[], representation_mmr VARCHAR[], representation_pos VARCHAR[], representative_docs VARCHAR[], llm_summary VARCHAR, PRIMARY KEY(run_id, topic_id));;
CREATE TABLE bridge_artist_id_to_names(artist_id_internal VARCHAR, observed_name_string VARCHAR);;
CREATE TABLE bridge_chunk_topic(run_id INTEGER, chunk_id BIGINT, topic_id INTEGER NOT NULL, PRIMARY KEY(run_id, chunk_id));;
CREATE TABLE bridge_kb_artist_to_kexp(kb_artist_id UUID, kexp_artist_id_internal UUID, PRIMARY KEY(kb_artist_id, kexp_artist_id_internal));;
CREATE TABLE bridge_kb_song_to_kexp(kb_song_id UUID, kexp_track_id_internal UUID, PRIMARY KEY(kb_song_id, kexp_track_id_internal));;
CREATE TABLE bridge_label_id_to_names(label_id_internal UUID, observed_label_name_string VARCHAR);;
CREATE TABLE bridge_play_to_artist(play_id BIGINT, artist_id_internal UUID);;
CREATE TABLE bridge_play_to_label(play_id BIGINT, label_id_internal UUID);;
CREATE TABLE bridge_release_id_to_names(release_id_internal UUID, observed_album_name_string VARCHAR);;
CREATE TABLE bridge_show_hosts(show_id BIGINT, host_id BIGINT);;
CREATE TABLE bridge_timeslot_hosts(timeslot_id BIGINT, host_id BIGINT);;
CREATE TABLE chunk_embeddings(chunk_id INTEGER PRIMARY KEY, embedding FLOAT[384] NOT NULL, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE comment_chunks_raw(chunk_id BIGINT, play_id BIGINT, strategy_id INTEGER, chunk_index INTEGER, chunk_text VARCHAR NOT NULL, chunk_length INTEGER NOT NULL, normalized_chunk_text VARCHAR NOT NULL, is_url_only BOOLEAN NOT NULL, contains_url BOOLEAN NOT NULL, alpha_ratio DOUBLE, alphanum_ratio DOUBLE, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), PRIMARY KEY(play_id, strategy_id, chunk_index));;
CREATE TABLE comment_splitting_strategies(strategy_id INTEGER PRIMARY KEY, strategy_name VARCHAR NOT NULL, description VARCHAR, split_pattern VARCHAR NOT NULL);;
CREATE TABLE dim_artists_master(artist_id_internal VARCHAR, primary_name_observed VARCHAR, mb_id VARCHAR);;
CREATE TABLE dim_hosts(host_id BIGINT, primary_name VARCHAR, host_uri VARCHAR);;
CREATE TABLE dim_labels_master(label_id_internal UUID, primary_name_observed VARCHAR, mb_id UUID);;
CREATE TABLE dim_programs(program_id BIGINT, primary_name VARCHAR, program_uri VARCHAR, description VARCHAR, tags VARCHAR, image_uri VARCHAR);;
CREATE TABLE dim_releases_master(release_id_internal UUID, primary_album_name_observed VARCHAR, mb_release_id UUID, mb_release_group_id UUID, release_date_iso DATE);;
CREATE TABLE dim_shows(show_id BIGINT, show_uri VARCHAR, program_id JSON, start_time_iso TIMESTAMP, tagline_at_show_time VARCHAR, title_at_show_time JSON, program_name_at_show_time VARCHAR, program_tags_at_show_time VARCHAR, host_ids_at_show_time BIGINT[]);;
CREATE TABLE dim_timeslots(timeslot_id BIGINT, program_id BIGINT, weekday BIGINT, start_date_iso DATE, end_date_iso DATE, start_time_str TIME, end_time_str TIME, duration_str INTERVAL);;
CREATE TABLE dim_tracks(track_id_internal VARCHAR, primary_song_title_observed VARCHAR, mb_track_id VARCHAR, mb_recording_id VARCHAR, release_id_internal_on_track VARCHAR);;
CREATE TABLE fact_plays(play_id BIGINT, airdate_iso TIMESTAMP, show_id BIGINT, track_id_internal UUID, "comment" VARCHAR, rotation_status VARCHAR, is_local BOOLEAN, is_request BOOLEAN, is_live BOOLEAN, play_type VARCHAR, original_artist_text VARCHAR, original_album_text VARCHAR, original_song_text VARCHAR);;
CREATE TABLE kb_Album(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, title VARCHAR NOT NULL, mb_release_group_id UUID UNIQUE, primary_type VARCHAR, secondary_types VARCHAR, first_release_date DATE, disambiguation VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Artist(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, "name" VARCHAR NOT NULL, sort_name VARCHAR, "type" ENUM('PERSON', 'GROUP', 'ORCHESTRA', 'CHOIR', 'CHARACTER', 'OTHER'), mb_artist_id UUID UNIQUE, begin_date DATE, end_date DATE, disambiguation VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Genre(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, "name" VARCHAR NOT NULL UNIQUE, mb_genre_id UUID, description VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Host(kb_id UUID PRIMARY KEY, "name" VARCHAR NOT NULL, kexp_host_id BIGINT UNIQUE, host_uri VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_KexpComment(kb_id UUID PRIMARY KEY, play_id BIGINT NOT NULL, comment_text VARCHAR NOT NULL, comment_length INTEGER NOT NULL, has_links BOOLEAN, contains_url BOOLEAN, comment_type VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Location(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, "name" VARCHAR NOT NULL, mb_area_id UUID UNIQUE, "type" VARCHAR, country_code VARCHAR, latitude DECIMAL(9,6), longitude DECIMAL(9,6), created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Play(kb_id UUID PRIMARY KEY, play_id BIGINT NOT NULL UNIQUE, airdate TIMESTAMP, rotation_status VARCHAR, is_local BOOLEAN, is_request BOOLEAN, is_live BOOLEAN, play_type VARCHAR, has_comment BOOLEAN, comment_length INTEGER, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Program(kb_id UUID PRIMARY KEY, "name" VARCHAR NOT NULL, kexp_program_id BIGINT UNIQUE, description VARCHAR, tags VARCHAR, program_uri VARCHAR, image_uri VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_RecordLabel(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, "name" VARCHAR NOT NULL, mb_label_id UUID, country VARCHAR, label_code INTEGER, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Relationship(triple_id VARCHAR PRIMARY KEY, subject_type VARCHAR NOT NULL, subject_id VARCHAR NOT NULL, predicate VARCHAR NOT NULL, object_type VARCHAR NOT NULL, object_id VARCHAR NOT NULL, source_name VARCHAR, target_name VARCHAR, mb_relation_type VARCHAR, mb_target_type VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Release(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, title VARCHAR NOT NULL, mb_release_id UUID UNIQUE, album_id UUID, release_date DATE, country VARCHAR, barcode VARCHAR, disambiguation VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Show(kb_id UUID PRIMARY KEY, kexp_show_id BIGINT NOT NULL UNIQUE, show_uri VARCHAR, start_time TIMESTAMP, title VARCHAR, tagline VARCHAR, program_name VARCHAR, program_tags VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE kb_Song(kb_id UUID DEFAULT(uuid()) PRIMARY KEY, title VARCHAR NOT NULL, length_ms INTEGER, mb_recording_id UUID UNIQUE, disambiguation VARCHAR, created_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP), updated_at TIMESTAMP DEFAULT(CURRENT_TIMESTAMP));;
CREATE TABLE mb_artists_raw("type" VARCHAR, id UUID, aliases STRUCT("name" VARCHAR, "sort-name" VARCHAR, "type-id" UUID, "begin" VARCHAR, locale VARCHAR, ended BOOLEAN, "end" VARCHAR, "primary" BOOLEAN, "type" VARCHAR)[], "life-span" STRUCT("end" VARCHAR, ended BOOLEAN, "begin" VARCHAR), area STRUCT("name" VARCHAR, "sort-name" VARCHAR, "iso-3166-1-codes" VARCHAR[], "type-id" JSON, disambiguation VARCHAR, id UUID, "type" JSON, "iso-3166-2-codes" VARCHAR[], "iso-3166-3-codes" VARCHAR[]), "begin-area" STRUCT("type" JSON, id UUID, "iso-3166-2-codes" VARCHAR[], disambiguation VARCHAR, "type-id" JSON, "sort-name" VARCHAR, "name" VARCHAR, "iso-3166-1-codes" VARCHAR[], "iso-3166-3-codes" VARCHAR[]), annotation VARCHAR, relations STRUCT(ended BOOLEAN, "type" VARCHAR, "type-id" UUID, "attribute-values" MAP(VARCHAR, VARCHAR), "target-credit" VARCHAR, "end" VARCHAR, direction VARCHAR, "attribute-ids" MAP(VARCHAR, UUID), "target-type" VARCHAR, attributes VARCHAR[], "begin" VARCHAR, "source-credit" VARCHAR, url STRUCT(id UUID, resource VARCHAR), "event" STRUCT("life-span" STRUCT("begin" VARCHAR, ended BOOLEAN, "end" VARCHAR), id UUID, "type" VARCHAR, cancelled BOOLEAN, "type-id" UUID, disambiguation VARCHAR, "name" VARCHAR, "time" VARCHAR, setlist VARCHAR), "label" STRUCT("name" VARCHAR, "sort-name" VARCHAR, disambiguation VARCHAR, "type-id" UUID, "label-code" BIGINT, "type" VARCHAR, id UUID), recording STRUCT(video BOOLEAN, disambiguation VARCHAR, title VARCHAR, id UUID, length BIGINT), "work" STRUCT("language" VARCHAR, languages VARCHAR[], id UUID, "type" VARCHAR, disambiguation VARCHAR, "type-id" UUID, attributes JSON[], iswcs VARCHAR[], title VARCHAR), artist STRUCT(country VARCHAR, disambiguation VARCHAR, "type-id" UUID, "name" VARCHAR, "sort-name" VARCHAR, id UUID, "type" VARCHAR), "attribute-credits" MAP(VARCHAR, VARCHAR), "release" STRUCT(barcode VARCHAR, id UUID, packaging JSON, country VARCHAR, "release-events" STRUCT(area STRUCT(disambiguation VARCHAR, "type-id" JSON, "iso-3166-1-codes" VARCHAR[], "sort-name" VARCHAR, "name" VARCHAR, "type" JSON, id UUID, "iso-3166-2-codes" VARCHAR[], "iso-3166-3-codes" VARCHAR[]), date VARCHAR)[], quality VARCHAR, status JSON, "status-id" JSON, "text-representation" STRUCT(script VARCHAR, "language" VARCHAR), title VARCHAR, date VARCHAR, "packaging-id" JSON, disambiguation VARCHAR), release_group STRUCT("first-release-date" VARCHAR, title VARCHAR, disambiguation VARCHAR, "primary-type" JSON, id UUID, "secondary-types" JSON[], "secondary-type-ids" JSON[], "primary-type-id" JSON), series STRUCT(id UUID, "type" VARCHAR, "type-id" UUID, disambiguation VARCHAR, "name" VARCHAR), "ordering-key" BIGINT, place STRUCT(id UUID, "type" VARCHAR, area STRUCT("iso-3166-2-codes" VARCHAR[], disambiguation VARCHAR, "type-id" UUID, "sort-name" VARCHAR, "name" VARCHAR, "type" VARCHAR, id UUID, "iso-3166-1-codes" VARCHAR[]), coordinates STRUCT(longitude DOUBLE, latitude DOUBLE), address VARCHAR, "name" VARCHAR, disambiguation VARCHAR, "type-id" UUID), genre STRUCT(id UUID, "name" VARCHAR, disambiguation VARCHAR), instrument STRUCT(disambiguation VARCHAR, "type-id" UUID, "name" VARCHAR, "type" VARCHAR, id UUID, description VARCHAR))[], "sort-name" VARCHAR, "type-id" UUID, country VARCHAR, "end-area" STRUCT("name" VARCHAR, "sort-name" VARCHAR, disambiguation VARCHAR, "type-id" JSON, id UUID, "type" JSON, "iso-3166-2-codes" VARCHAR[], "iso-3166-1-codes" VARCHAR[]), isnis VARCHAR[], ipis VARCHAR[], "gender-id" UUID, tags STRUCT(count BIGINT, "name" VARCHAR)[], gender VARCHAR, genres STRUCT(id UUID, count BIGINT, disambiguation VARCHAR, "name" VARCHAR)[], rating STRUCT("votes-count" BIGINT, "value" DOUBLE), "name" VARCHAR, disambiguation VARCHAR);;
CREATE TABLE mb_relations_enhanced(artist_mb_id UUID, artist_name VARCHAR, relation_type VARCHAR, target_type VARCHAR, attributes_raw VARCHAR[], attributes_array VARCHAR[], begin_date VARCHAR, end_date VARCHAR);;
CREATE MACRO main.contains_url ("text") AS (CASE  WHEN ((("text" IS NULL) OR (length("text") = 0))) THEN (CAST('f' AS BOOLEAN)) ELSE regexp_matches("text", 'https?://[^\s/$.?#].[^\s]*|[a-zA-Z0-9.-]+\.(?:com|org|net|edu|gov|io|ly|eu|info|biz|ws|us|ca|uk|au|de|jp|fr|ch|fm|tv|me|sh|stream|live|watch|listen|download|video|audio|pics|photo|img|image|gallery|news|blog|shop|store|app|co|info|online|site|website|xyz|club|dev|page|link|art|bandcamp|soundcloud|spotify|youtube|youtu\.be|vimeo|tiktok|instagram|facebook|twitter|patreon|kexp)(?:/[^\s]*)?') END);;
CREATE MACRO main.is_url_only ("text") AS (CASE  WHEN ((("text" IS NULL) OR (length("text") = 0))) THEN (CAST('f' AS BOOLEAN)) ELSE regexp_matches("text", '^https?://[^\s/$.?#].[^\s]*$|^[a-zA-Z0-9.-]+\.(?:com|org|net|edu|gov|io|ly|eu|info|biz|ws|us|ca|uk|au|de|jp|fr|ch|fm|tv|me|sh|stream|live|watch|listen|download|video|audio|pics|photo|img|image|gallery|news|blog|shop|store|app|co|info|online|site|website|xyz|club|dev|page|link|art|bandcamp|soundcloud|spotify|youtube|youtu\.be|vimeo|tiktok|instagram|facebook|twitter|patreon|kexp)(?:/[^\s]*)?$') END);;
CREATE MACRO main.normalize_comment_text ("text") AS (CASE  WHEN (("text" IS NULL)) THEN ('') ELSE main."trim"(regexp_replace(regexp_replace(regexp_replace(regexp_replace(regexp_replace(CAST("text" AS VARCHAR), '---', ' ', 'g'), '--', ' ', 'g'), '—', ' ', 'g'), '–', ' ', 'g'), '\s+', ' ', 'g')) END);;
CREATE MACRO main.uuid_generate_v4 () AS ('uuid_uuid_v4');;
CREATE VIEW chunk_embeddings_with_metadata AS SELECT ce.chunk_id, ce.embedding, ce.created_at, c.play_id, c.strategy_id, c.chunk_index, c.chunk_text, c.normalized_chunk_text, c.chunk_length, c.alpha_ratio, c.alphanum_ratio, c.is_url_only, c.contains_url, fp.original_artist_text, fp.original_song_text, fp.airdate_iso FROM chunk_embeddings AS ce INNER JOIN comment_chunks_raw AS c ON ((ce.chunk_id = c.chunk_id)) INNER JOIN fact_plays AS fp ON ((c.play_id = fp.play_id)) WHERE (c.strategy_id = 3);;
CREATE VIEW view_artist_play_summary AS SELECT bpa.artist_id_internal, dam.primary_name_observed AS artist_primary_name, dam.mb_id AS artist_mbid, count(DISTINCT bpa.play_id) AS total_plays, count(DISTINCT fp.track_id_internal) AS distinct_tracks_played FROM bridge_play_to_artist AS bpa INNER JOIN dim_artists_master AS dam ON ((bpa.artist_id_internal = dam.artist_id_internal)) INNER JOIN fact_plays AS fp ON ((bpa.play_id = fp.play_id)) GROUP BY bpa.artist_id_internal, dam.primary_name_observed, dam.mb_id;;
CREATE VIEW view_chunks_per_comment_distribution AS SELECT s.strategy_name, chunks_per_comment, count_star() AS comment_count, round(((count_star() * 100.0) / sum(count_star()) OVER (PARTITION BY s.strategy_name)), 2) AS percentage FROM (SELECT strategy_id, play_id, count_star() AS chunks_per_comment FROM comment_chunks_raw GROUP BY strategy_id, play_id) AS chunk_counts INNER JOIN comment_splitting_strategies AS s ON ((chunk_counts.strategy_id = s.strategy_id)) GROUP BY s.strategy_name, chunks_per_comment ORDER BY s.strategy_name, chunks_per_comment;;
CREATE VIEW view_chunk_stats_by_strategy AS SELECT s.strategy_name, count(DISTINCT c.play_id) AS comments_processed, count_star() AS total_chunks, avg(c.chunk_length) AS avg_chunk_length, median(c.chunk_length) AS median_chunk_length, min(c.chunk_length) AS min_chunk_length, max(c.chunk_length) AS max_chunk_length, sum(CASE  WHEN (c.is_url_only) THEN (1) ELSE 0 END) AS url_only_chunks, sum(CASE  WHEN (c.contains_url) THEN (1) ELSE 0 END) AS chunks_with_urls, avg(c.alpha_ratio) AS avg_alpha_ratio, avg(c.alphanum_ratio) AS avg_alphanum_ratio FROM comment_chunks_raw AS c INNER JOIN comment_splitting_strategies AS s ON ((c.strategy_id = s.strategy_id)) GROUP BY s.strategy_name, s.strategy_id ORDER BY s.strategy_id;;
CREATE VIEW view_filtered_chunks AS SELECT c.*, s.strategy_name, p.airdate_iso, p.show_id, p.original_artist_text, p.original_song_text FROM comment_chunks_raw AS c INNER JOIN comment_splitting_strategies AS s ON ((c.strategy_id = s.strategy_id)) INNER JOIN fact_plays AS p ON ((c.play_id = p.play_id)) WHERE ((c.chunk_length >= 10) AND (NOT c.is_url_only) AND (c.alpha_ratio >= 0.3) AND (c.alphanum_ratio >= 0.5));;
CREATE VIEW view_play_details AS SELECT fp.play_id, fp.airdate_iso, fp."comment", fp.play_type, fp.rotation_status, fp.is_local, fp.is_request, fp.is_live, fp.original_artist_text AS play_artist_text, fp.original_album_text AS play_album_text, fp.original_song_text AS play_song_text, dt.track_id_internal, dt.primary_song_title_observed AS track_song_title, dt.mb_track_id AS musicbrainz_track_id, dt.mb_recording_id AS musicbrainz_recording_id, drm.release_id_internal AS track_release_id_internal, drm.primary_album_name_observed AS track_album_name, drm.mb_release_id AS track_mb_release_id, drm.mb_release_group_id AS track_mb_release_group_id, drm.release_date_iso AS track_release_date, ds.show_id, ds.start_time_iso AS show_start_time, ds.tagline_at_show_time AS show_tagline, ds.program_id AS show_program_id, dp.primary_name AS show_program_name FROM fact_plays AS fp LEFT JOIN dim_tracks AS dt ON ((fp.track_id_internal = dt.track_id_internal)) LEFT JOIN dim_releases_master AS drm ON ((dt.release_id_internal_on_track = drm.release_id_internal)) LEFT JOIN dim_shows AS ds ON ((fp.show_id = ds.show_id)) LEFT JOIN dim_programs AS dp ON ((ds.program_id = dp.program_id));;
CREATE VIEW view_sample_chunks AS SELECT s.strategy_name, c.play_id, c.chunk_index, c.chunk_length, c.normalized_chunk_text, c.is_url_only, c.contains_url, round(c.alpha_ratio, 3) AS alpha_ratio, round(c.alphanum_ratio, 3) AS alphanum_ratio FROM comment_chunks_raw AS c INNER JOIN comment_splitting_strategies AS s ON ((c.strategy_id = s.strategy_id)) WHERE (c.chunk_length BETWEEN 20 AND 200) ORDER BY random() LIMIT 100;;
CREATE VIEW view_show_host_details AS SELECT s.show_id, s.start_time_iso AS show_start_time, s.tagline_at_show_time, h.host_id, h.primary_name AS host_name FROM dim_shows AS s INNER JOIN bridge_show_hosts AS bsh ON ((s.show_id = bsh.show_id)) INNER JOIN dim_hosts AS h ON ((bsh.host_id = h.host_id));;
CREATE VIEW view_track_comment_summary AS SELECT dt.track_id_internal, dt.primary_song_title_observed AS track_song_title, count(fp.play_id) AS total_plays, sum(CASE  WHEN (((fp."comment" IS NOT NULL) AND (fp."comment" != ''))) THEN (1) ELSE 0 END) AS plays_with_comments, string_agg(fp."comment", ' ||| ') FILTER (WHERE ((fp."comment" IS NOT NULL) AND (fp."comment" != ''))) AS all_comments_concatenated FROM dim_tracks AS dt INNER JOIN fact_plays AS fp ON ((dt.track_id_internal = fp.track_id_internal)) GROUP BY dt.track_id_internal, dt.primary_song_title_observed;;
CREATE UNIQUE INDEX idx_comment_chunks_raw_chunk_id ON comment_chunks_raw(chunk_id);;
CREATE INDEX idx_hnsw_chunk_embeddings ON chunk_embeddings USING HNSW (embedding);;

